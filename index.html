<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <title>Endless Overtake ‚Äî zero-build</title>

    <!-- Tailwind (CDN) for the existing UI classes -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- React 18 UMD + ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

    <!-- THREE.js (UMD) -->
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

    <!-- Babel Standalone (to transpile TSX in-browser) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      html, body, #root { height: 100%; }
      body { background:#0b0c10; }
    </style>
  </head>
  <body>
    <div id="root" class="h-full"></div>

    <!-- Your entire game, unchanged logic, transpiled by Babel in the browser -->
    <script type="text/babel" data-presets="typescript,react">
      // ==== Canvas: Endless Overtake ‚Äî 3d Browser Racing (zero-build) ====

      const { useEffect, useRef, useState } = React;

      // ==== Compact build + roguelike loop + mid-run glitches (kept slim) ====

      const SPEED_STAGES=[{capKmh:100,goal:3},{capKmh:130,goal:4},{capKmh:160,goal:5},{capKmh:190,goal:6},{capKmh:220,goal:7},{capKmh:250,goal:8},{capKmh:280,goal:9}];
      const TUNING={lateralAccel:28,dampingX:6,baseAccel:9.5,brakeAccel:16,autoUp:2.4,autoDown:3,oncomingSeedCount:4,oncomingSeedZStart:80,oncomingSpacing:70,oncomingSeedRand:30,sameSeedCount:6,sameSeedZStart:50,sameSeedSpacing:35,sameSeedRand:30,oncomingSpawnProb:0.35,oncomingRespawnMin:180,oncomingRespawnVar:140,sameRespawnMin:120,sameRespawnVar:160,oncomingSpeedMin:16,oncomingSpeedMax:24,sameSpeedMin:12,sameSpeedMax:23,ttcDanger:1,ttcWarn:2.2,laneMarginX:0.15,corridorRedSec:1.2,corridorAmberSec:2.5,corridorWidthMargin:0.45,followHeadwaySec:1.3,followMinGap:3,followBrakeSoft:3,followBrakeHard:8.5,followLeadMargin:0.4,npcAccel:3,npcMinSpeed:6,minSpawnGapSame:22,minSpawnGapOncoming:26,overtakeIntentSec:0.6,followBandScale:0.6,camFollowLerp:0.22,camYawFactor:0.06,camRollFactor:0.02,lookSensitivity:0.0025,lookPitchLimit:0.35,lookYawLimit:0.6,leanX:-0.55,leanY:0.08,leanYaw:-0.5,leanHoldScale:1.5,scrapePushK:24,scrapeSlowK:2.2,crashRelSpeedSame:7,crashImpactOncoming:2,laneOffsetMax:0.35,laneWanderAmpSame:0.10,laneWanderAmpOncoming:0.14,laneWanderFreqMin:0.4,laneWanderFreqMax:0.9,laneEdgeMargin:0.22,avoidLookaheadSec:1.6,avoidLookaheadDist:38,avoidTriggerGap:1.25,avoidXMax:0.55,avoidLerp:0.08,avoidRelaxLerp:0.04,avoidSkillThreshold:0.35,comboAdd:0.5,comboDecay:0.28};
      const DEFAULT_PARAMS={...TUNING,speedScale:1,hitboxXExtra:0.85,hitboxZExtra:1.6,fovMin:40,fovMax:58};
      const CURVE={A1:2.2,A2:1.2,F1:(2*Math.PI)/520,F2:(2*Math.PI)/810,PH2:2.1};
      const curveXAtS=(s)=>CURVE.A1*Math.sin(CURVE.F1*s)+CURVE.A2*Math.sin(CURVE.F2*s+CURVE.PH2);
      const curveDXAtS=(s)=>CURVE.A1*CURVE.F1*Math.cos(CURVE.F1*s)+CURVE.A2*CURVE.F2*Math.cos(CURVE.F2*s+CURVE.PH2);
      const kmh=(mps)=>(mps*3.6)|0;

      // meta (persistent)
      const loadMeta=()=>{try{const s=localStorage.getItem("eo_meta");if(!s)throw 0;const m=JSON.parse(s);return {c:m.c|0,u:{a:m.u?.a|0,b:m.u?.b|0,s:m.u?.s|0,l:m.u?.l|0}}}catch{ return {c:0,u:{a:0,b:0,s:0,l:0}}}};
      const saveMeta=(m)=>{try{localStorage.setItem("eo_meta",JSON.stringify(m))}catch{}};
      const upCost=(lvl)=>10*(1<<Math.min(10,lvl));

      // run mods (pick 1 of 3 at start)
      const MODS={list:[
        {n:"Nitro",d:"Accel +25%, Max +5%",ma:.25,ms:.05},
        {n:"Sharp Brakes",d:"Brake +30%",mb:.30},
        {n:"Sticky Tires",d:"Lateral +25%",ml:.25},
        {n:"Hot Streak",d:"Combo +0.15",hc:.15},
      ], pick:(k)=>{const arr=[];let used=new Set();while(arr.length<k&&used.size<MODS.list.length){const i=(Math.random()*MODS.list.length)|0;if(!used.has(i)){used.add(i);arr.push(i)}}return arr}};

      // mid-run GLITCHES: temporary, random, change gameplay
      const GLITCHES={list:[
        {n:"Bullet Time",d:"Time slows near danger. +20% score",dur:22,a:(m)=>{m.near=1;m.score*=1.2;}},
        {n:"Needle Threader",d:"Half width hitbox; ‚Äì10% score",dur:28,a:(m)=>{m.hitX=0.5;m.score*=0.9;}},
        {n:"Truck Mode",d:"Long hitbox, heavier scrapes",dur:30,a:(m)=>{m.hitZ=1.6;m.scrape=1.4;}},
        {n:"Reverse Flow",d:"More oncoming spawns. +30% score",dur:26,a:(m)=>{m.spawn=0.35;m.score*=1.3;}},
        {n:"Snake Road",d:"Road curves swell",dur:24,a:(m)=>{m.curve=1.8;}},
        {n:"Lean Ghost",d:"Leaning shrinks width by 50%",dur:25,a:(m)=>{m.ghost=1;}},
        {n:"Fog Bank",d:"Heavy fog. +15% score",dur:22,a:(m)=>{m.fog=1;m.score*=1.15;}},
        {n:"Nitro Drip",d:"+20% accel",dur:24,a:(m)=>{m.acc=1.2;}},
        // New, wilder ones
        {n:"Mirror Controls",d:"Steering inverted",dur:18,a:(m)=>{m.inv=1;}},
        {n:"Tunnel Vision",d:"Tighter FOV. +10% score",dur:20,a:(m)=>{m.fovTight=1;m.score*=1.1;}},
        {n:"Fisheye",d:"Wider FOV. ‚Äì10% score",dur:20,a:(m)=>{m.fovWide=1;m.score*=0.9;}},
        {n:"Slipstream Draft",d:"Boost when tailing",dur:26,a:(m)=>{m.slip=1;}},
        {n:"Drift King",d:"+50% lateral, ‚Äì40% damping",dur:22,a:(m)=>{m.lat=1.5;m.damp=0.6;}},
        {n:"Greased Road",d:"‚Äì30% lateral, ‚Äì30% brake",dur:22,a:(m)=>{m.lat=0.7;m.brk=0.7;}},
        {n:"Blade Runner",d:"Faster oncoming. +20% score",dur:24,a:(m)=>{m.onc=1.35;m.score*=1.2;}},
        {n:"Car-nival",d:"More same-lane spawns",dur:24,a:(m)=>{m.spawnSame=0.3;}},
        {n:"Quake",d:"Cab shakes",dur:18,a:(m)=>{m.shake=1;}},
        {n:"Straight Shot",d:"Road straightens",dur:22,a:(m)=>{m.curve=0.6;}},
      ], pick:(k)=>{const arr=[];let used=new Set();while(arr.length<k&&used.size<GLITCHES.list.length){const i=(Math.random()*GLITCHES.list.length)|0;if(!used.has(i)){used.add(i);arr.push(i)}}return arr}};

      // sanity checks (tiny runtime tests)
      (()=>{try{
        for(let i=1;i<SPEED_STAGES.length;i++)console.assert(SPEED_STAGES[i].capKmh>SPEED_STAGES[i-1].capKmh,'stages increasing');
        console.assert(kmh(10/3.6)===10,'kmh conv');
        console.assert(TUNING.followHeadwaySec>0&&TUNING.followHeadwaySec<5,'headway sanity');
        console.assert(DEFAULT_PARAMS.fovMax>DEFAULT_PARAMS.fovMin&&DEFAULT_PARAMS.fovMin>30,'fov bounds');
        const mp=MODS.pick(3);console.assert(new Set(mp).size===mp.length&&mp.length<=MODS.list.length,"unique mod picks");
        const gp=GLITCHES.pick(2);console.assert(new Set(gp).size===gp.length&&gp.length<=GLITCHES.list.length,"unique glitch picks");
        console.assert(upCost(0)===10&&upCost(1)===20,"upCost");
        // curve smoothness quick check
        const a=curveXAtS(1000),b=curveXAtS(1001);console.assert(Math.abs(a-b)<10,'curve continuity');
      }catch(e){}})();

      function RacingGame(){
        const mountRef=useRef(null),vignetteRef=useRef(null);
        const hudSpeedRef=useRef(null),hudOvertakesRef=useRef(null),hudGoalRef=useRef(null),hudStageRef=useRef(null);
        const hudSpeedBarRef=useRef(null),hudScoreRef=useRef(null),hudComboRef=useRef(null),hudHeatBarRef=useRef(null);

        const restartRef=useRef(()=>{}); const startRunRef=useRef(()=>{});

        const [crashed,setCrashed]=useState(false),[leanHeld,setLeanHeld]=useState(false),[showPanel,setShowPanel]=useState(false);
        const [inRun,setInRun]=useState(false);const inRunRef=useRef(false);useEffect(()=>{inRunRef.current=inRun},[inRun]);
        const [meta,setMeta]=useState(loadMeta());const metaRef=useRef(meta);useEffect(()=>{metaRef.current=meta;},[meta]);
        const [shopOpen,setShopOpen]=useState(false);
        const [modPick,setModPick]=useState(null);const runModRef=useRef({});
        const [lastEarn,setLastEarn]=useState(0);const [lastStats,setLastStats]=useState({score:0,overtakes:0,meters:0});
        const [glitchPick,setGlitchPick]=useState(null);const glitchPickRef=useRef(null);useEffect(()=>{glitchPickRef.current=glitchPick;},[glitchPick]);
        const [activeGlitch,setActiveGlitch]=useState(null);
        const mutRef=useRef({near:0,hitX:1,hitZ:1,scrape:1,spawn:0,curve:1,ghost:0,fog:0,acc:1,score:1,inv:0,fovTight:0,fovWide:0,slip:0,lat:1,damp:1,brk:1,onc:1,shake:0,spawnSame:0});
        const mutUntilRef=useRef(0); const mutPendingRef=useRef(null);

        // params
        const [params,setParams]=useState(DEFAULT_PARAMS);const cfgRef=useRef(params);useEffect(()=>{cfgRef.current=params;},[params]);const baseParamsRef=useRef(params);
        const leanRef=useRef(false);useEffect(()=>{leanRef.current=leanHeld;},[leanHeld]);
        const scaledCaps=SPEED_STAGES.map(s=>Math.round(s.capKmh*params.speedScale));const maxScaledCap=scaledCaps[scaledCaps.length-1];

        const applyAll=(p)=>{const u=metaRef.current.u,m=runModRef.current;const r={...p};r.baseAccel*=1+0.05*u.a; r.brakeAccel*=1+0.05*u.b; r.speedScale*=1+0.03*u.s; r.lateralAccel*=1+0.05*u.l; if(m.ma)r.baseAccel*=1+m.ma; if(m.mb)r.brakeAccel*=1+m.mb; if(m.ml)r.lateralAccel*=1+m.ml; if(m.ms)r.speedScale*=1+m.ms; if(m.hc)r.comboAdd+=m.hc; return r};
        const resetMut=()=>{mutRef.current={near:0,hitX:1,hitZ:1,scrape:1,spawn:0,curve:1,ghost:0,fog:0,acc:1,score:1,inv:0,fovTight:0,fovWide:0,slip:0,lat:1,damp:1,brk:1,onc:1,shake:0,spawnSame:0};mutUntilRef.current=0;setActiveGlitch(null)};
        const openGlitch=()=>setGlitchPick(GLITCHES.pick(2));
        const chooseGlitch=(i)=>{if(!glitchPick)return;const g=GLITCHES.list[glitchPick[i]];mutPendingRef.current=g;setGlitchPick(null)};

        // === 3D scene ===
        useEffect(()=>{const container=mountRef.current;if(!container)return;const renderer=new THREE.WebGLRenderer({antialias:true,alpha:true});renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));renderer.setSize(container.clientWidth,container.clientHeight);renderer.shadowMap.enabled=true;container.appendChild(renderer.domElement);
          const scene=new THREE.Scene();scene.background=new THREE.Color(0x111217);scene.fog=new THREE.Fog(0x111217,25,260);
          const camera=new THREE.PerspectiveCamera(cfgRef.current.fovMin,container.clientWidth/container.clientHeight,0.1,1000);camera.position.set(0,1.15,0);const camRig=new THREE.Group();scene.add(camRig);camRig.add(camera);
          scene.add(new THREE.HemisphereLight(0xffffff,0x222233,0.6));const dir=new THREE.DirectionalLight(0xffffff,0.8);dir.position.set(-10,20,-10);dir.castShadow=true;dir.shadow.mapSize.set(2048,2048);scene.add(dir);
          const ROAD_WIDTH=6,SHOULDER=1.5,ROAD_HALF=ROAD_WIDTH*0.5,LANE_RIGHT_X=1.8,LANE_LEFT_X=-1.8,PLAYER_WIDTH=1.7,PLAYER_LENGTH=3.8;
          const state={playerX:LANE_RIGHT_X,playerVx:0,playerSpeed:20,overtakes:0,stage:0,crashed:false,time:0};const rt={...state,crashed:false,time:0,scroll:0,keys:new Set(),targetSpeed:(SPEED_STAGES[0].capKmh*cfgRef.current.speedScale*1000)/3600,score:0,comboHeat:0,nextGlitchAt:3};
          const sFromRelZ=(relZ)=>rt.scroll-relZ;const curveX=(s)=>curveXAtS(s)*(mutRef.current.curve||1);const curveDX=(s)=>curveDXAtS(s)*(mutRef.current.curve||1);const worldX=(relX,relZ)=>curveX(sFromRelZ(relZ))+relX;

          const roadGroup=new THREE.Group();scene.add(roadGroup);const size=64,c=document.createElement('canvas');c.width=size;c.height=size;const g=c.getContext('2d');g.fillStyle='rgb(255,255,204)';g.fillRect(0,0,size,size*0.48);const dashTex=new THREE.CanvasTexture(c);dashTex.wrapS=dashTex.wrapT=THREE.RepeatWrapping;dashTex.anisotropy=4;const DASH_PERIOD=6;
          function makeStrip(w,len,sx,sz,mat,relOff){const verts=(sx+1)*(sz+1),pos=new Float32Array(verts*3),nrm=new Float32Array(verts*3),uv=new Float32Array(verts*2);for(let v=0;v<verts;v++){nrm[v*3+1]=1;}const idx=[];for(let j=0;j<sz;j++){for(let i=0;i<sx;i++){const a=j*(sx+1)+i,b=a+1,c=a+(sx+1),d=c+1;idx.push(a,c,b,b,c,d)}}const geom=new THREE.BufferGeometry();geom.setIndex(idx);geom.setAttribute('position',new THREE.BufferAttribute(pos,3));geom.setAttribute('normal',new THREE.BufferAttribute(nrm,3));geom.setAttribute('uv',new THREE.BufferAttribute(uv,2));const mesh=new THREE.Mesh(geom,mat);const update=(cz)=>{let p=0,t=0;for(let j=0;j<=sz;j++){const zL=-len/2+(j/sz)*len,wZ=cz+zL,s=sFromRelZ(wZ),cx=curveX(s);for(let i=0;i<=sx;i++){const xL=-w/2+(i/sx)*w+relOff;pos[p++]=cx+xL;pos[p++]=0;pos[p++]=wZ;uv[t++]=i/sx;uv[t++]=j/sz}}geom.attributes.position.needsUpdate=true;geom.attributes.uv.needsUpdate=true};return{mesh,update,length:len}};
          const roadMat=new THREE.MeshPhongMaterial({color:0x2a2b30,side:THREE.DoubleSide}),edgeMat=new THREE.MeshBasicMaterial({color:0xf0f0f0,side:THREE.DoubleSide});
          function makeRoadSeg(zStart){const LEN=120,base=makeStrip(ROAD_WIDTH+2*SHOULDER,LEN,8,64,roadMat,0),leftE=makeStrip(0.08,LEN,1,64,edgeMat,-ROAD_HALF),rightE=makeStrip(0.08,LEN,1,64,edgeMat,ROAD_HALF),centerMat=new THREE.MeshBasicMaterial({color:0xffffff,map:dashTex,transparent:true,alphaTest:0.5,side:THREE.DoubleSide}),center=makeStrip(0.12,LEN,1,64,centerMat,0);[base.mesh,leftE.mesh,rightE.mesh,center.mesh].forEach(m=>roadGroup.add(m));let cz=zStart;const update=()=>{base.update(cz);leftE.update(cz);rightE.update(cz);center.update(cz);const startZ=cz-center.length/2,off=((startZ/DASH_PERIOD)%1+1)%1;centerMat.map.repeat.set(1,center.length/DASH_PERIOD);centerMat.map.offset.set(0,off);centerMat.map.needsUpdate=true};return{centerZ:cz,update}};
          const roadSegs=[makeRoadSeg(-60),makeRoadSeg(60),makeRoadSeg(180)];roadSegs.forEach(s=>s.update());

          const streakGroup=new THREE.Group();scene.add(streakGroup);const streaks=[];const streakGeom=new THREE.BoxGeometry(0.06,0.02,1.2),streakMat=new THREE.MeshBasicMaterial({color:0xffffff,transparent:true,opacity:0.35});function spawnStreak(){const m=new THREE.Mesh(streakGeom,streakMat.clone());m.position.y=0.06+Math.random()*0.12;const side=Math.random()<0.5?-1:1,edgeRel=(ROAD_WIDTH*0.5+0.25)*side;m.position.z=-(80+Math.random()*160);m.position.x=worldX(edgeRel+(Math.random()-0.5)*0.4,m.position.z);streakGroup.add(m);streaks.push(m)}for(let i=0;i<80;i++)spawnStreak();

          const cockpit=new THREE.Group();const dash=new THREE.Mesh(new THREE.BoxGeometry(2.2,0.2,0.7),new THREE.MeshStandardMaterial({color:0x111111,metalness:0.2,roughness:0.6}));dash.position.set(0,-0.25,-0.5);const hood=new THREE.Mesh(new THREE.BoxGeometry(1.4,0.08,1.6),new THREE.MeshStandardMaterial({color:0x30333a,metalness:0.4,roughness:0.5}));hood.position.set(0,-0.35,-1.5);const wheel=new THREE.Mesh(new THREE.TorusGeometry(0.16,0.03,12,32),new THREE.MeshStandardMaterial({color:0x181818,metalness:0.2,roughness:0.8}));wheel.rotation.x=Math.PI/2;wheel.position.set(0,-0.15,-0.15);cockpit.add(dash,hood,wheel);camera.add(cockpit);

          function spawnCar(o){const carGeo=new THREE.BoxGeometry(1.7,1,3.6);const carMats=[0xff5555,0x55aaff,0xffaa00,0x66cc66,0xbb88ff,0xffffff,0xdddddd].map(c=>new THREE.MeshStandardMaterial({color:c,metalness:0.4,roughness:0.4}));const mesh=new THREE.Mesh(carGeo,carMats[(Math.random()*carMats.length)|0]);mesh.castShadow=mesh.receiveShadow=true;const laneX=o.lane==="left"?-1.8:1.8;const z=o.z??-(80+Math.random()*140);const base=o.speed??(o.dir==="same"?TUNING.sameSpeedMin+Math.random()*(TUNING.sameSpeedMax-TUNING.sameSpeedMin):TUNING.oncomingSpeedMin+Math.random()*(TUNING.oncomingSpeedMax-TUNING.oncomingSpeedMin));const laneOffset=(Math.random()*2-1)*TUNING.laneOffsetMax,wanderAmp=(o.dir==="same"?TUNING.laneWanderAmpSame:TUNING.laneWanderAmpOncoming)*(0.6+Math.random()*0.8),wanderFreq=TUNING.laneWanderFreqMin+Math.random()*(TUNING.laneWanderFreqMax-TUNING.laneWanderFreqMin),wanderPhase=Math.random()*Math.PI*2,avoidOffset=0,avoidSkill=Math.random();mesh.position.set(worldX(laneX+laneOffset,z),0.5,z);scene.add(mesh);const t={mesh,dir:o.dir,laneX,speed:base,speedBase:base,overtaken:false,laneOffset,wanderAmp,wanderFreq,wanderPhase,avoidOffset,avoidSkill};traffic.push(t);return t}
          function safeSpawnZ(dir){const base=dir==="same"?-(TUNING.sameRespawnMin+Math.random()*TUNING.sameRespawnVar):-(TUNING.oncomingRespawnMin+Math.random()*TUNING.oncomingRespawnVar);const minGap=dir==="same"?TUNING.minSpawnGapSame:TUNING.minSpawnGapOncoming;let z=base,loops=0;while(loops<20){const tooClose=traffic.some(u=>u.dir===dir&&u.mesh.position.z<0&&Math.abs(u.mesh.position.z-z)<minGap);if(!tooClose)break;z-=minGap;loops++}return z}
          const traffic=[];for(let i=0;i<TUNING.sameSeedCount;i++)spawnCar({dir:"same",lane:"right",z:-(TUNING.sameSeedZStart+i*TUNING.sameSeedSpacing+Math.random()*TUNING.sameSeedRand)});
          for(let i=0;i<TUNING.oncomingSeedCount;i++)spawnCar({dir:"oncoming",lane:"left",z:-(TUNING.oncomingSeedZStart+i*TUNING.oncomingSpacing+Math.random()*TUNING.oncomingSeedRand)});

          const down=(e)=>{rt.keys.add(e.key.toLowerCase());if(e.key.toLowerCase()==="r"&&rt.crashed) startRunRef.current();};
          const up=(e)=>rt.keys.delete(e.key.toLowerCase());
          window.addEventListener("keydown",down);window.addEventListener("keyup",up);

          let lookYaw=0,lookPitch=0;const sens=TUNING.lookSensitivity;let drag=false,lastX=0,lastY=0;
          function onClickCanvas(_ev){}
          function onMouseDown(ev){if(ev.button===2){drag=true;lastX=ev.clientX;lastY=ev.clientY;window.addEventListener("mousemove",onMouseMoveWin);window.addEventListener("mouseup",onMouseUpWin);}if(ev.button===0)setLeanHeld(true);} 
          function onMouseUpCanvas(ev){if(ev.button===0)setLeanHeld(false);} 
          function onMouseMove(_ev){} 
          function onMouseMoveWin(ev){if(!drag)return;const dx=ev.clientX-lastX,dy=ev.clientY-lastY;lastX=ev.clientX;lastY=ev.clientY;lookYaw+=dx*sens;lookPitch-=dy*sens;lookYaw=THREE.MathUtils.clamp(lookYaw,-TUNING.lookYawLimit,TUNING.lookYawLimit);lookPitch=THREE.MathUtils.clamp(lookPitch,-TUNING.lookPitchLimit,TUNING.lookPitchLimit);} 
          function onMouseUpWin(){drag=false;window.removeEventListener("mousemove",onMouseMoveWin);window.removeEventListener("mouseup",onMouseUpWin);} 
          function preventMenu(e){e.preventDefault();}
          container.addEventListener("click",onClickCanvas);container.addEventListener("mousedown",onMouseDown);container.addEventListener("mouseup",onMouseUpCanvas);container.addEventListener("mousemove",onMouseMove);container.addEventListener("contextmenu",preventMenu);

          const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));const stageCapKmh=(st)=>SPEED_STAGES[Math.max(0,Math.min(st,SPEED_STAGES.length-1))].capKmh*cfgRef.current.speedScale;
          function updateHUD(){const maxCap=SPEED_STAGES[SPEED_STAGES.length-1].capKmh*cfgRef.current.speedScale,pct=Math.min(100,Math.max(0,(kmh(rt.playerSpeed)/maxCap)*100));if(hudSpeedBarRef.current)hudSpeedBarRef.current.style.width=pct+"%";if(hudSpeedRef.current)hudSpeedRef.current.textContent=`${kmh(rt.playerSpeed)} km/h`;if(hudOvertakesRef.current)hudOvertakesRef.current.textContent=`${rt.overtakes}`;if(hudGoalRef.current)hudGoalRef.current.textContent=`${SPEED_STAGES[rt.stage]?.goal??"-"}`;if(hudStageRef.current)hudStageRef.current.textContent=`${rt.stage+1}`;const mult=1+Math.floor(Math.max(0,Math.min(1,rt.comboHeat))*4);if(hudScoreRef.current)hudScoreRef.current.textContent=`${rt.score}`;if(hudComboRef.current)hudComboRef.current.textContent=`x${mult}`;if(hudHeatBarRef.current)hudHeatBarRef.current.style.width=`${Math.max(0,Math.min(1,rt.comboHeat))*100}%`;const maxMps=(maxCap*1000)/3600,s=Math.min(1,rt.playerSpeed/maxMps);if(vignetteRef.current)vignetteRef.current.style.opacity=(0.12+s*0.38).toFixed(2)}

          const clock=new THREE.Clock();
          function sameAheadCount(){let n=0;for(const t of traffic)if(t.dir==="same"&&t.mesh.position.z<-10&&t.mesh.position.z>-220)n++;return n}
          function maybeAdvanceStage(){const curr=SPEED_STAGES[rt.stage];if(!curr)return;if(rt.overtakes>=curr.goal){rt.stage=Math.min(rt.stage+1,SPEED_STAGES.length-1);rt.targetSpeed=(stageCapKmh(rt.stage)*1000)/3600; if(sameAheadCount()<6)spawnCar({dir:"same",lane:"right",z:safeSpawnZ("same")}); else spawnCar({dir:"oncoming",lane:"left",z:safeSpawnZ("oncoming")});}}
          function resetWorld(){for(const t of traffic)scene.remove(t.mesh);traffic.length=0;for(let i=0;i<6;i++)spawnCar({dir:"same",lane:"right",z:-(50+i*35+Math.random()*20)});for(let i=0;i<6;i++)spawnCar({dir:"oncoming",lane:"left",z:-(60+i*40+Math.random()*25)});}    
          function restart(){rt.playerX=1.8;rt.playerVx=0;rt.playerSpeed=20;rt.targetSpeed=(stageCapKmh(0)*1000)/3600;rt.overtakes=0;rt.score=0;rt.comboHeat=0;rt.stage=0;rt.crashed=false;rt.scroll=0;rt.nextGlitchAt=3;resetMut();setCrashed(false);resetWorld();updateHUD();}
          restartRef.current=restart;

          // lean state that ramps with hold time
          let leanAmt=0; // [0..1]

          function animate(){
            // pending glitch application (set by UI) happens here so we know rt.time
            if(mutPendingRef.current){const g=mutPendingRef.current;mutPendingRef.current=null;resetMut();g.a(mutRef.current);mutUntilRef.current=rt.time+(g.dur||24);setActiveGlitch(g.n)}
            const baseDt=clock.getDelta();
            // bullet-time near danger
            let danger=0;if(mutRef.current.near){for(const t of traffic){if(t.dir!=='oncoming')continue;const dz=t.mesh.position.z;if(dz>=0)continue;const rel=rt.playerSpeed+t.speed*(mutRef.current.onc||1);if(rel<=0)continue;const tRelX=t.mesh.position.x-curveX(sFromRelZ(dz));const latGap=Math.abs(rt.playerX-tRelX);const ttc=(-dz)/rel;if(ttc<1.6&&latGap<0.7){const d=1.6-ttc;danger=Math.max(danger,d/1.6)}}}
            const tScale= danger? (1-0.6*Math.min(1,danger)) : 1;
            const dt=Math.min(0.033,baseDt*tScale);
            if(!inRunRef.current||rt.crashed||glitchPickRef.current){renderer.render(scene,camera);requestAnimationFrame(animate);return;}

            // expire glitch
            if(mutUntilRef.current>0&&rt.time>mutUntilRef.current){resetMut();}

            rt.time+=dt;const left=rt.keys.has("a")||rt.keys.has("arrowleft"),right=rt.keys.has("d")||rt.keys.has("arrowright");
            let accelX=(left?-1:0)+(right?1:0); if(mutRef.current.inv)accelX*=-1; 
            rt.playerVx+=accelX*cfgRef.current.lateralAccel*(mutRef.current.lat||1)*dt;rt.playerVx-=rt.playerVx*cfgRef.current.dampingX*(mutRef.current.damp||1)*dt;rt.playerX+=rt.playerVx*dt;const roadLimit=3-0.4;if(Math.abs(rt.playerX)>roadLimit)rt.playerVx+=-Math.sign(rt.playerX)*cfgRef.current.lateralAccel*1.2*dt;
            const LANE_WIDTH=3,LANE_HALF_W=LANE_WIDTH*0.5;let leadDist=Infinity;let leadSpeed=null;const projectedX=rt.playerX+rt.playerVx*TUNING.overtakeIntentSec;for(const t of traffic){if(t.dir!=="same")continue;const dz0=t.mesh.position.z;if(dz0>=0)continue;const dist=-dz0,tRelX=t.mesh.position.x-curveX(sFromRelZ(dz0)),sameNow=Math.abs(rt.playerX-tRelX)<LANE_HALF_W*TUNING.followBandScale,sameSoon=Math.abs(projectedX-tRelX)<LANE_HALF_W*TUNING.followBandScale;if(!(sameNow&&sameSoon))continue;if(dist<leadDist){leadDist=dist;leadSpeed=t.speed}}
            const upKey=rt.keys.has("w")||rt.keys.has("arrowup"),downKey=rt.keys.has("s")||rt.keys.has("arrowdown"),intendOvertake=(accelX!==0)&&upKey;if(upKey)rt.playerSpeed+=cfgRef.current.baseAccel*(mutRef.current.acc||1)*dt;if(downKey)rt.playerSpeed-=cfgRef.current.brakeAccel*(mutRef.current.brk||1)*dt; if(leadSpeed!==null){const closing=rt.playerSpeed-(leadSpeed);if(closing>0){const ttc=leadDist/closing;if(leadDist<TUNING.followMinGap*0.9||(!intendOvertake&&ttc<TUNING.ttcDanger))rt.playerSpeed-=TUNING.followBrakeHard*dt;else if(!intendOvertake&&ttc<TUNING.ttcWarn)rt.playerSpeed-=TUNING.followBrakeSoft*dt;}}
            // slipstream boost when tailing closely
            if(mutRef.current.slip && leadSpeed!==null && leadDist<10 && upKey){const boost=THREE.MathUtils.clamp((10-leadDist)/10,0,1);rt.playerSpeed+= (1.8+2.2*boost)*dt;}
            const cap=(SPEED_STAGES[Math.min(rt.stage,SPEED_STAGES.length-1)].capKmh*cfgRef.current.speedScale*1000)/3600;if(upKey&&rt.playerSpeed<cap)rt.playerSpeed+=cfgRef.current.autoUp*dt;if(!upKey&&rt.playerSpeed>cap)rt.playerSpeed-=cfgRef.current.autoDown*dt;rt.playerSpeed=clamp(rt.playerSpeed,5,(SPEED_STAGES[SPEED_STAGES.length-1].capKmh*cfgRef.current.speedScale*1000)/3600);
            const roadDz=rt.playerSpeed*dt;rt.scroll+=roadDz;const wheel=cockpit.children.find(c=>c.geometry instanceof THREE.TorusGeometry);if(wheel)wheel.rotation.z=THREE.MathUtils.clamp(-rt.playerVx*0.06,-0.5,0.5);
            for(const seg of roadSegs){seg.centerZ+=roadDz;if(seg.centerZ>180)seg.centerZ-=360;seg.update();}
            const maxMps=(SPEED_STAGES[SPEED_STAGES.length-1].capKmh*cfgRef.current.speedScale*1000)/3600,sn=Math.min(1,rt.playerSpeed/maxMps);for(const m of streaks){m.scale.z=THREE.MathUtils.lerp(m.scale.z||1,0.6+sn*2.2,0.15);m.position.z+=roadDz+rt.playerSpeed*0.9*dt;if(m.position.z>60){m.position.z=-(120+Math.random()*160);m.position.y=0.06+Math.random()*0.12;}const sSt=sFromRelZ(m.position.z),desX=curveX(sSt)+(m.position.x-curveX(sSt));m.position.x=THREE.MathUtils.lerp(m.position.x,desX,0.25)}
            const oncomingFactor=(mutRef.current.onc||1);
            const LANE_WIDTH_LOC=3,LANE_HALF=LANE_WIDTH_LOC*0.5,bandW=LANE_HALF*TUNING.followBandScale;for(let i=traffic.length-1;i>=0;i--){const t=traffic[i];const tRelX=t.mesh.position.x-curveX(sFromRelZ(t.mesh.position.z));let leadZ=null,leadV=0;if(0<t.mesh.position.z&&Math.abs(rt.playerX-tRelX)<bandW){leadZ=0;leadV=rt.playerSpeed}for(const u of traffic){if(u===t||u.dir!==t.dir)continue;const uRelX=u.mesh.position.x-curveX(sFromRelZ(u.mesh.position.z));if(Math.abs(uRelX-tRelX)>bandW)continue;if(u.mesh.position.z<t.mesh.position.z){const dist=t.mesh.position.z-u.mesh.position.z;if(leadZ===null||dist<t.mesh.position.z-(leadZ)){leadZ=u.mesh.position.z;leadV=u.speed}}}if(leadZ!==null){const dist=t.mesh.position.z-(leadZ),closing=t.speed-leadV;if(closing>0){const ttc=dist/closing;if(dist<TUNING.followMinGap*0.9||ttc<TUNING.ttcDanger)t.speed=Math.max(TUNING.npcMinSpeed,t.speed-TUNING.followBrakeHard*dt);else if(ttc<TUNING.ttcWarn)t.speed=Math.max(TUNING.npcMinSpeed,t.speed-TUNING.followBrakeSoft*dt);}}else{if(t.speed<t.speedBase)t.speed=Math.min(t.speedBase,t.speed+TUNING.npcAccel*dt);else if(t.speed>t.speedBase)t.speed=Math.max(t.speedBase,t.speed-TUNING.npcAccel*0.5*dt);}const relV=t.dir==="same"?rt.playerSpeed-t.speed:rt.playerSpeed+t.speed*oncomingFactor;t.mesh.position.z+=relV*dt;{let desRel=t.laneX+t.laneOffset+t.wanderAmp*Math.sin(rt.time*t.wanderFreq+t.wanderPhase);if(t.dir==="oncoming"){const dz=t.mesh.position.z,rel=rt.playerSpeed+t.speed*oncomingFactor;if(dz<0&&rel>0){const dist=-dz,ttc=dist/rel,latGap=Math.abs(rt.playerX-tRelX);if(ttc<TUNING.avoidLookaheadSec&&dist<TUNING.avoidLookaheadDist&&latGap<TUNING.avoidTriggerGap&&t.avoidSkill>TUNING.avoidSkillThreshold){const close=Math.max(0,Math.min(1,1-latGap/TUNING.avoidTriggerGap)),bias=rt.playerX>0?1:0.7,goal=-TUNING.avoidXMax*bias*close;t.avoidOffset=THREE.MathUtils.lerp(t.avoidOffset,goal,TUNING.avoidLerp)}else t.avoidOffset=THREE.MathUtils.lerp(t.avoidOffset,0,TUNING.avoidRelaxLerp)}desRel+=t.avoidOffset}const minRel=t.laneX-LANE_HALF+TUNING.laneEdgeMargin,maxRel=t.laneX+LANE_HALF-TUNING.laneEdgeMargin;desRel=THREE.MathUtils.clamp(desRel,minRel,maxRel);const sCar=sFromRelZ(t.mesh.position.z),desX=curveX(sCar)+desRel;t.mesh.position.x=THREE.MathUtils.lerp(t.mesh.position.x,desX,0.08)}if(t.dir==="same"&&!t.overtaken&&t.mesh.position.z>1.2){t.overtaken=true;rt.overtakes++;rt.comboHeat=Math.min(1,rt.comboHeat+cfgRef.current.comboAdd);const mult=1+Math.floor(rt.comboHeat*4);rt.score+=Math.round(100*mult*(mutRef.current.score||1));updateHUD();maybeAdvanceStage();if(rt.overtakes>=rt.nextGlitchAt){rt.nextGlitchAt+=3+((Math.random()*2)|0);openGlitch();}}
            if(t.mesh.position.z>60){scene.remove(t.mesh);traffic.splice(i,1);const sameF=sameAheadCount();let d;const bias=clamp(TUNING.oncomingSpawnProb+(mutRef.current.spawn||0)-(mutRef.current.spawnSame||0),0,0.9);if(sameF>6)d="oncoming";else if(sameF<3)d="same";else d=Math.random()<bias?"oncoming":"same";if(d==="oncoming")spawnCar({dir:"oncoming",lane:"left",z:safeSpawnZ("oncoming")});else spawnCar({dir:"same",lane:"right",z:safeSpawnZ("same")});continue}}
            if(!rt.crashed){for(const t of traffic){const dz=t.mesh.position.z;if(Math.abs(dz)>PLAYER_LENGTH*0.5+2)continue;const tRelX=t.mesh.position.x-curveX(sFromRelZ(dz)),dx=tRelX-rt.playerX;const exExtra=cfgRef.current.hitboxXExtra*(mutRef.current.hitX||1)*((mutRef.current.ghost&& (leanRef.current||rt.keys.has('q')))?0.5:1);const ezExtra=cfgRef.current.hitboxZExtra*(mutRef.current.hitZ||1);const hitX=Math.abs(dx)<PLAYER_WIDTH*0.5+exExtra,hitZ=Math.abs(dz)<PLAYER_LENGTH*0.5+ezExtra;if(hitX&&hitZ){const relZ=t.dir==="same"?rt.playerSpeed-t.speed:rt.playerSpeed+t.speed*oncomingFactor;const depthX=(PLAYER_WIDTH*0.5+exExtra)-Math.abs(dx),depthZ=(PLAYER_LENGTH*0.5+ezExtra)-Math.abs(dz),impact=Math.max(0,relZ)*Math.max(0.1,depthZ);if(t.dir==="oncoming"){if(impact>TUNING.crashImpactOncoming){rt.crashed=true;setCrashed(true); setInRun(false); setLastStats({score:rt.score,overtakes:rt.overtakes,meters:Math.floor(rt.scroll)}); setLastEarn(calcEarn(rt)); break}}else{if(relZ>TUNING.crashRelSpeedSame){rt.crashed=true;setCrashed(true); setInRun(false); setLastStats({score:rt.score,overtakes:rt.overtakes,meters:Math.floor(rt.scroll)}); setLastEarn(calcEarn(rt)); break}}const pushDir=-Math.sign(dx)||-1;rt.playerVx+=pushDir*TUNING.scrapePushK*(mutRef.current.scrape||1)*depthX*dt;rt.playerSpeed-=Math.min(3,0.5+TUNING.scrapeSlowK*depthZ)*dt; if(dz>0&&t.dir==="same")t.speed=Math.max(TUNING.npcMinSpeed,t.speed-(TUNING.followBrakeHard*0.8)*dt);}}if(Math.abs(rt.playerX)>ROAD_HALF+SHOULDER*0.8){rt.crashed=true;setCrashed(true); setInRun(false); setLastStats({score:rt.score,overtakes:rt.overtakes,meters:Math.floor(rt.scroll)}); setLastEarn(calcEarn(rt));}}
            const centerNow=curveX(rt.scroll),headingNow=Math.atan(curveDX(rt.scroll));camRig.position.x=THREE.MathUtils.lerp(camRig.position.x,centerNow+rt.playerX,TUNING.camFollowLerp);camRig.rotation.z=THREE.MathUtils.lerp(camRig.rotation.z,-rt.playerVx*TUNING.camRollFactor,0.08);const yawP=THREE.MathUtils.clamp(-rt.playerVx*TUNING.camYawFactor,-0.25,0.25);camRig.rotation.y=THREE.MathUtils.lerp(camRig.rotation.y,headingNow+yawP,0.08);
            // mouse-look + lean (progressive, slower retract)
            const upRate=2.2,downRate=0.9;const wantLean=((leanRef.current||rt.keys.has('q'))?1:0);leanAmt+= (wantLean-leanAmt) * (wantLean?upRate:downRate) * dt;const side=rt.playerX>=0?1:-1;const leanDir=-side;const leanXLocal=TUNING.leanX*leanDir*TUNING.leanHoldScale*leanAmt;const leanYLocal=TUNING.leanY*TUNING.leanHoldScale*leanAmt;const leanYawLocal=TUNING.leanYaw*leanDir*TUNING.leanHoldScale*leanAmt;
            camera.rotation.y=THREE.MathUtils.lerp(camera.rotation.y,lookYaw+leanYawLocal,0.18);camera.rotation.x=THREE.MathUtils.lerp(camera.rotation.x,lookPitch,0.18);camera.position.x=THREE.MathUtils.lerp(camera.position.x,leanXLocal,0.15);const bob=1.15+leanYLocal+Math.sin(rt.time*22)*0.006*sn;camera.position.y=THREE.MathUtils.lerp(camera.position.y,bob,0.15);if(mutRef.current.shake){camera.rotation.z=THREE.MathUtils.lerp(camera.rotation.z,Math.sin(rt.time*50)*0.02,0.25)} else {camera.rotation.z*=0.9}
            const maxMps2=(SPEED_STAGES[SPEED_STAGES.length-1].capKmh*cfgRef.current.speedScale*1000)/3600,s2=Math.min(1,rt.playerSpeed/maxMps2);let tFov=THREE.MathUtils.lerp(cfgRef.current.fovMin,cfgRef.current.fovMax,s2);if(mutRef.current.fovTight)tFov-=8;if(mutRef.current.fovWide)tFov+=10;if(mutRef.current.fog)tFov-=6;camera.fov=THREE.MathUtils.clamp(THREE.MathUtils.lerp(camera.fov,tFov,0.06),30,120);camera.updateProjectionMatrix();scene.fog.near=mutRef.current.fog?18:25;scene.fog.far=THREE.MathUtils.lerp(scene.fog.far,mutRef.current.fog?140:260,0.1);
            rt.comboHeat=Math.max(0,rt.comboHeat-cfgRef.current.comboDecay*dt);if((performance.now()|0)%6===0)updateHUD();renderer.render(scene,camera);requestAnimationFrame(animate)}

          function calcEarn(rt){return Math.max(1, (rt.score/300|0) + (rt.scroll/250|0) + (rt.overtakes|0) + rt.stage*2)}

          function startNewRunInner(){baseParamsRef.current=params;const eff={...applyAll(params)};cfgRef.current=eff;setParams(eff);setCrashed(false);setInRun(true);runModRef.current=runModRef.current||{};resetMut();restart();requestAnimationFrame(animate);} startRunRef.current=startNewRunInner;

          window._eoStart=()=>startRunRef.current(); updateHUD();requestAnimationFrame(animate);
          function onResize(){if(!container)return;const w=container.clientWidth,h=container.clientHeight;camera.aspect=w/h;camera.updateProjectionMatrix();renderer.setSize(w,h)}
          const ro=new ResizeObserver(onResize);ro.observe(container);
          return()=>{ro.disconnect();window.removeEventListener("keydown",down);window.removeEventListener("keyup",up);container.removeEventListener("click",onClickCanvas);container.removeEventListener("mousedown",onMouseDown);container.removeEventListener("mouseup",onMouseUpCanvas);container.removeEventListener("mousemove",onMouseMove);container.removeEventListener("contextmenu",preventMenu);window.removeEventListener("mousemove",onMouseMoveWin);window.removeEventListener("mouseup",onMouseUpWin);renderer.dispose();try{container.removeChild(renderer.domElement)}catch{}};
        },[]);

        // UI actions
        const openModPick=()=>{setModPick(MODS.pick(3));};
        const chooseMod=(i)=>{if(modPick){runModRef.current={...MODS.list[modPick[i]]}; setModPick(null); startRunRef.current();}};
        const bankAndReturn=()=>{const m={...metaRef.current};m.c=(m.c|0)+(lastEarn|0); setMeta(m); saveMeta(m); setCrashed(false); setInRun(false); runModRef.current={}; setModPick(null); setParams(baseParamsRef.current)};
        const buy=(k)=>{const m={...meta};const lvl=m.u[k]|0,c=upCost(lvl);if(m.c>=c){m.c-=c;m.u[k]=lvl+1;setMeta(m);saveMeta(m)}};

        const handleRestart=()=>{openModPick()};

        return (
          <div className="relative w-full h-[80vh] bg-black overflow-hidden rounded-2xl shadow-xl">
            <div ref={mountRef} className="absolute inset-0" />
            <div ref={vignetteRef} className="pointer-events-none absolute inset-0" style={{background:"radial-gradient(ellipse at center, rgba(0,0,0,0) 40%, rgba(0,0,0,0.85) 100%)",opacity:0.15,transition:"opacity 120ms linear"}}/>

            {/* HUD compact */}
            <div className="absolute top-3 left-3 right-3 flex flex-wrap gap-2 text-white/90 font-mono text-xs select-none">
              <div className="backdrop-blur-md bg-black/30 rounded-xl px-3 py-2 shadow w-60">
                <div className="text-[10px] uppercase tracking-widest opacity-70">Speed</div>
                <div ref={hudSpeedRef} className="text-2xl font-semibold">0 km/h</div>
                <div className="relative mt-2 h-2 bg-white/10 rounded-full overflow-hidden">
                  <div ref={hudSpeedBarRef} className="h-full bg-white/90" style={{width:"0%"}}/>
                  {scaledCaps.map((cap,i)=>(<div key={i} className="absolute top-0 h-full w-px bg-white/40" style={{left:`${(cap/maxScaledCap)*100}%`}}/>))}
                </div>
                <div className="mt-1 text-[10px] flex justify-between opacity-60"><span>0</span><span>{maxScaledCap} km/h</span></div>
              </div>
              <div className="backdrop-blur-md bg-black/30 rounded-xl px-3 py-2 shadow w-52">
                <div className="flex items-center justify-between"><div className="text-[10px] uppercase tracking-widest opacity-70">Score</div><div ref={hudComboRef} className="text-sm font-bold opacity-90">x1</div></div>
                <div ref={hudScoreRef} className="text-2xl font-semibold">0</div>
                <div className="relative mt-2 h-2 bg-white/10 rounded-full overflow-hidden"><div ref={hudHeatBarRef} className="h-full bg-amber-300" style={{width:"0%"}}/></div>
              </div>
              <div className="grid grid-cols-3 gap-2 w-[240px]">
                <div className="backdrop-blur-md bg-black/30 rounded-xl px-3 py-2 text-center"><div className="text-[10px] uppercase tracking-widest opacity-70">Overtakes</div><div ref={hudOvertakesRef} className="text-lg">0</div></div>
                <div className="backdrop-blur-md bg-black/30 rounded-xl px-3 py-2 text-center"><div className="text-[10px] uppercase tracking-widest opacity-70">Goal</div><div ref={hudGoalRef} className="text-lg">-</div></div>
                <div className="backdrop-blur-md bg-black/30 rounded-xl px-3 py-2 text-center"><div className="text-[10px] uppercase tracking-widest opacity-70">Stage</div><div ref={hudStageRef} className="text-lg">1</div></div>
              </div>
              {activeGlitch && (<div className="ml-auto backdrop-blur-md bg-purple-500/20 border border-purple-300/30 rounded-xl px-3 py-2 text-xs">‚ö° {activeGlitch}</div>)}
            </div>

            <div className="absolute bottom-3 left-3 flex gap-2">
              <button onPointerDown={()=>setLeanHeld(true)} onPointerUp={()=>setLeanHeld(false)} onPointerLeave={()=>setLeanHeld(false)} className="px-3 py-2 rounded-xl bg-white/90 text-black font-semibold hover:bg-white active:scale-[0.98]">Lean</button>
              <button onClick={()=>setShowPanel(s=>!s)} className="px-3 py-2 rounded-xl bg-white/90 text-black font-semibold hover:bg-white" title="Tuning">‚öôÔ∏è</button>
              <button onClick={()=>setShopOpen(s=>!s)} className="px-3 py-2 rounded-xl bg-white/90 text-black font-semibold hover:bg-white" title="Garage">üè™</button>
              <button onClick={handleRestart} className="px-3 py-2 rounded-xl bg-white/90 text-black font-semibold hover:bg-white">{inRun?"New Run":"Start Run"}</button>
            </div>

            {/* Tuning */}
            {showPanel&&(
              <div className="absolute bottom-14 left-3 w-80 max-w-[90vw] backdrop-blur-md bg-black/60 text-white rounded-2xl p-4 shadow-2xl space-y-3">
                <div className="font-semibold mb-1">Tuning (per-run)</div>
                <div><label className="text-xs opacity-80">Max Speed Scale: <span className="font-mono">{params.speedScale.toFixed(2)}√ó</span></label><input type="range" min={0.5} max={2} step={0.01} value={params.speedScale} onChange={e=>setParams({...params,speedScale:parseFloat(e.target.value)})} className="w-full"/></div>
                <div><label className="text-xs opacity-80">Accel (m/s¬≤): <span className="font-mono">{params.baseAccel.toFixed(1)}</span></label><input type="range" min={1} max={25} step={0.1} value={params.baseAccel} onChange={e=>setParams({...params,baseAccel:parseFloat(e.target.value)})} className="w-full"/></div>
                <div><label className="text-xs opacity-80">Brake (m/s¬≤): <span className="font-mono">{params.brakeAccel.toFixed(1)}</span></label><input type="range" min={2} max={60} step={0.1} value={params.brakeAccel} onChange={e=>setParams({...params,brakeAccel:parseFloat(e.target.value)})} className="w-full"/></div>
                <div className="grid grid-cols-2 gap-3"><div><label className="text-xs opacity-80">FOV Min: <span className="font-mono">{params.fovMin.toFixed(0)}¬∞</span></label><input type="range" min={40} max={85} step={1} value={params.fovMin} onChange={e=>setParams({...params,fovMin:parseFloat(e.target.value)})} className="w-full"/></div><div><label className="text-xs opacity-80">FOV Max: <span className="font-mono">{params.fovMax.toFixed(0)}¬∞</span></label><input type="range" min={params.fovMin+1} max={95} step={1} value={params.fovMax} onChange={e=>setParams({...params,fovMax:parseFloat(e.target.value)})} className="w-full"/></div></div>
                <div className="grid grid-cols-2 gap-3"><div><label className="text-xs opacity-80">Hitbox +W (m): <span className="font-mono">{params.hitboxXExtra.toFixed(2)}</span></label><input type="range" min={0.2} max={1.5} step={0.01} value={params.hitboxXExtra} onChange={e=>setParams({...params,hitboxXExtra:parseFloat(e.target.value)})} className="w-full"/></div><div><label className="text-xs opacity-80">Hitbox +L (m): <span className="font-mono">{params.hitboxZExtra.toFixed(2)}</span></label><input type="range" min={0.4} max={3} step={0.01} value={params.hitboxZExtra} onChange={e=>setParams({...params,hitboxZExtra:parseFloat(e.target.value)})} className="w-full"/></div></div>
              </div>
            )}

            {/* Garage (meta upgrades) */}
            {shopOpen&&(
              <div className="absolute bottom-14 left-3 w-80 max-w-[90vw] backdrop-blur-md bg-black/70 text-white rounded-2xl p-4 shadow-2xl space-y-2">
                <div className="flex items-center justify-between"><div className="font-semibold">Garage</div><div className="font-mono text-sm">üí∞ {meta.c}</div></div>
                <div className="grid grid-cols-[1fr_auto_auto] gap-x-2 gap-y-1 items-center text-xs">
                  <div>Accel +5%/lvl (lv {meta.u.a})</div><div className="opacity-80">{upCost(meta.u.a)}$</div><button onClick={()=>buy('a')} className="bg-white/90 text-black px-2 py-1 rounded">Buy</button>
                  <div>Brake +5%/lvl (lv {meta.u.b})</div><div className="opacity-80">{upCost(meta.u.b)}$</div><button onClick={()=>buy('b')} className="bg-white/90 text-black px-2 py-1 rounded">Buy</button>
                  <div>MaxSpeed +3%/lvl (lv {meta.u.s})</div><div className="opacity-80">{upCost(meta.u.s)}$</div><button onClick={()=>buy('s')} className="bg-white/90 text-black px-2 py-1 rounded">Buy</button>
                  <div>Lateral +5%/lvl (lv {meta.u.l})</div><div className="opacity-80">{upCost(meta.u.l)}$</div><button onClick={()=>buy('l')} className="bg-white/90 text-black px-2 py-1 rounded">Buy</button>
                </div>
                <div className="text-[11px] opacity-70">Upgrades are permanent. Apply on next run.</div>
              </div>
            )}

            {/* Start menu / Mod picker */}
            {!inRun && !crashed && (
              <div className="absolute inset-0 flex items-center justify-center">
                <div className="backdrop-blur-xl bg-black/60 text-white p-6 rounded-2xl shadow-2xl text-center max-w-md mx-auto space-y-3">
                  <div className="text-2xl font-bold">Endless Overtake</div>
                  {modPick? (
                    <>
                      <div className="text-sm opacity-80">Pick a run mod</div>
                      <div className="grid grid-cols-1 gap-2">
                        {modPick.map((idx,i)=> (
                          <button key={i} onClick={()=>chooseMod(i)} className="px-3 py-2 rounded-xl bg-white/90 text-black font-semibold hover:bg-white">
                            {MODS.list[idx].n} ‚Äî <span className="opacity-80">{MODS.list[idx].d}</span>
                          </button>
                        ))}
                      </div>
                    </>
                  ) : (
                    <>
                      <div className="text-sm opacity-80">Start a run, then overtake to build heat & score. Crash to bank credits.</div>
                      <div className="font-mono text-sm">üí∞ Credits: {meta.c}</div>
                      <div className="flex gap-2 justify-center">
                        <button onClick={openModPick} className="px-4 py-2 rounded-xl bg-white/90 text-black font-semibold hover:bg-white">Start Run</button>
                        <button onClick={()=>setShopOpen(s=>!s)} className="px-4 py-2 rounded-xl bg-white/20 hover:bg-white/25">Garage</button>
                      </div>
                    </>
                  )}
                </div>
              </div>
            )}

            {/* Crash / end-of-run overlay */}
            {crashed&&(
              <div className="absolute inset-0 flex items-center justify-center">
                <div className="backdrop-blur-xl bg-black/60 text-white p-6 rounded-2xl shadow-2xl text-center max-w-sm mx-auto space-y-2">
                  <div className="text-3xl font-bold">Run Over</div>
                  <div className="text-sm opacity-90">Score {lastStats.score} ¬∑ Overtakes {lastStats.overtakes} ¬∑ Meters {lastStats.meters}</div>
                  <div className="text-lg">üí∞ Earned: <span className="font-bold">{lastEarn}</span></div>
                  <div className="flex gap-2 justify-center mt-2">
                    <button onClick={()=>{bankAndReturn(); openModPick();}} className="px-4 py-2 rounded-xl bg-white/90 text-black font-semibold hover:bg-white">Bank & New Run</button>
                    <button onClick={bankAndReturn} className="px-4 py-2 rounded-xl bg-white/20 hover:bg-white/25">Bank & Menu</button>
                  </div>
                </div>
              </div>
            )}

            {/* Mid-run GLITCH picker (pauses sim) */}
            {inRun && glitchPick && (
              <div className="absolute inset-0 flex items-center justify-center">
                <div className="backdrop-blur-xl bg-purple-900/40 ring-1 ring-white/10 text-white p-6 rounded-2xl shadow-2xl text-center max-w-md mx-auto space-y-3">
                  <div className="text-xl font-bold">‚ö° Anomaly!</div>
                  <div className="grid grid-cols-1 gap-2">
                    {glitchPick.map((idx,i)=> (
                      <button key={i} onClick={()=>chooseGlitch(i)} className="px-3 py-2 rounded-xl bg-white/90 text-black font-semibold hover:bg-white">
                        {GLITCHES.list[idx].n} ‚Äî <span className="opacity-80">{GLITCHES.list[idx].d}</span>
                      </button>
                    ))}
                  </div>
                </div>
              </div>
            )}
          </div>
        );
      }

      // Mount
      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(React.createElement(RacingGame));
    </script>
  </body>
</html>
